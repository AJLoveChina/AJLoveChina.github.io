<p>
    我们在前端处理页面滚动的时候往往这样处理：
</p>
<pre class="brush:js;toolbar:false">$(window).on(&quot;scroll&quot;, function () {
    // do something..
});</pre>
<p>
    这种做法有个问题，在用户滚动的时候，代码块中的逻辑会在短时间内大量执行，大概是每秒执行35次，如果代码块中的逻辑有点耗时（大约超过30ms）就会出现性能问题，造成页面滚动卡顿效果。类似的还有 window resize事件。<br/>
</p>
<p>
    我以前在腾讯UED的博客中看到一个做法非常不错：
</p>
<pre class="brush:js;toolbar:false">var timer;
$(window).on(&quot;scroll&quot;, function () {
 if (!timer){
   timer = setTimeout(function () {
     // do something...
     timer = 0;
   }, 1000 / 5)
 }
});</pre>
<p>
    这个做法意思就是每200ms执行一下do something的逻辑，类似这样的功能叫做<code>节流阀</code>。最重要的是<code>节流阀</code>不仅适用于scroll、resize这样的事件处理，任何短时间内会大量触发的函数，但是又不需要它们短时间内执行的场景都可以借鉴该思想。
</p>
<ol class=" list-paddingleft-2" style="list-style-type: decimal;">
    <li>
        <p>
            比如说，用户点击按钮触发一个行为，有的用户就可能疯狂点击！
        </p>
    </li>
    <li>
        <p>
            还比如：监听输入框用户输入（keyup）然后提供输入提示，用户输入很快，你完全没必要对于每次keyup都触发提示，只要在大约每500ms提供提示就可以了，不仅性能好，而且用户体验好（因为不会出现提示快速随着用户输入而改变）
        </p>
    </li>
</ol>
<p>
    点击<a target="_blank" href="//jsbin.com/zurarow/edit?html,js,output" style="white-space: normal;">链接(JSBin.com)</a>可以感性的看一下这个优化能到什么程度。
</p>
<p>
    <br/>
</p>
<p>
    但是我今天要说的不是这个，嘿嘿：）
</p>
<p>
    我想说这个做法有待优化，因为每次我这么做，都需要写一个类似 if (!timer) ..... timer = 0 ..... 这样的模版代码，这很烦，不符合软件设计的复用思想，所以我们把这个节流阀功能封装起来：
</p>
<pre class="brush:js;toolbar:false">// myThrottle函数就是对这个
var myThrottle = function (fn, interval) {
  var timer = 0;
  return function () {
    if (!timer) {
      fn();
      timer = setTimeout(function () {
        timer = 0;
      }, interval)
    }
  }
}

var doSomething = myThrottle(function () {
  // do something..
}, 1000 / 5)

$(window).on(&quot;scroll&quot;, function () {
 doSomething()
})</pre>
<p>
    我们使用<code>myThrottle</code>将节流阀功能封装起来，这样以后你什么函数需要一定时间内只执行一次就可以直接用<code>myThrottle</code>函数包装一下就好了，再也不用写里面那几行模版代码了。
</p>
<p>
    本来一切事情都是这么美好，直到有一天我发现<code>underscore</code>居然提供了这样的函数。。。是的！看下面这个代码：
</p>
<pre class="brush:js;toolbar:false">var throttle = _.throttle(function () {
  // do something...
}, 1000 / 5)
$(window).on(&quot;scroll&quot;, throttle);</pre>
<p>
    throttle的功能和上面的myThrottle功能是一样的，只不过throttle更加强大并且健壮，它还接受一个额外的参数，有兴趣的童鞋可以看看。所以说啊，如果你的项目中加载了underscore类似的工具库就别重复造轮子了~~当然如果你们还在裸写jQuery的话，还是可以把这个功能加到你们自己写的函数库里面去的。
</p>
<p>
    总结：这篇文章主要不在于介绍window scroll事件是如何优化的 ，而是希望读者能够理解<code>web前端短时间内大量执行同一函数的性能优化</code>该怎么做，这才是笔者的目标与愿望：）。
</p>
<p>
    PPS：还有啊，underscore还有个函数叫<code>debounce</code>，功能和<code>throttle</code>类似，不过有点区别，感兴趣的童鞋可以看看。
</p>
<p>
    这里给个<a target="_blank" href="//jsbin.com/zurarow/edit?html,js,output">链接(JSBin.com)</a>可以感性的看一下这个优化能到什么程度
</p>