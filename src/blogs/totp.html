<p>
    TOTP算法，英文缩写：Time-Based One Time Password，意思就是“基于时间的一次性密码”。
</p>
<p>
    该算法是“双重认证”的核心算法，而哈希算法又是TOTP算法的核心算法。
</p>
<blockquote>
    <p>
        A：卧槽，原来就是哈希算法啊，我以为多牛逼呢？
    </p>
    <p>
        J：是的，就是哈希算法的一个应用，但却是装x利器 &nbsp;：）
    </p>
</blockquote>
<p>
    言归正传。
</p>
<p>
    在说TOTP之前，先简单介绍一下哈希算法（hash），你不必了解hash的实现细节，你把hash看成一个函数。它能把任何不同的输入变成完全不同并且长度还固定的输出，它有俩个非常神奇的点：
</p>
<ol class=" list-paddingleft-2" style="list-style-type: decimal;">
    <li>
        <p>
            哈希(A)得到B，然后告诉你B， 你就是算不出来A
        </p>
    </li>
    <li>
        <p>
            你找不到俩个不同的值，然后哈希结果一样
        </p>
    </li>
</ol>
<p>
    <br/>
</p>
<p>
    那么hash怎么就跟TOTP扯上关系了呢？
</p>
<p>
    你四不四傻？看下面公式
</p>
<p>
    hash（当前时间）= 一次性密码
</p>
<p>
    这不就是基于时间的一次性密码了嘛，只不过这个密码基本没什么卵用，参考下面场景：
</p>
<ol class=" list-paddingleft-2" style="list-style-type: decimal;">
    <li>
        <p>
            坏人丙盗取了甲的Google密码123，然后登录Google。
        </p>
    </li>
    <li>
        <p>
            这时候Google说：我怎么知道你是甲，请输入“基于时间的一次性密码”！
        </p>
    </li>
    <li>
        <p>
            坏人丙hash（当前时间）得到一次性密码，然后输入。
        </p>
    </li>
    <li>
        <p>
            坏人成功。
        </p>
    </li>
</ol>
<p>
    <br/>
</p>
<p>
    卧槽，这TOTP有卵用！好，改进一下：
</p>
<p>
    hash（当前时间+固定不变的一段字符串）= 一次性密码
</p>
<p>
    再次参考上面场景：
</p>
<ol class=" list-paddingleft-2" style="list-style-type: decimal;">
    <li>
        <p>
            坏人丙盗取了甲的Google密码123，然后登录Google。
        </p>
    </li>
    <li>
        <p>
            这时候Google说：我怎么知道你是甲，请输入TOTP！
        </p>
    </li>
    <li>
        <p>
            坏人丙 hash（当前时间 + 固定不变的一段字符串），发现！卧槽这个固定不变的字符串是什么？？？
        </p>
    </li>
    <li>
        <p>
            坏人失败。
        </p>
    </li>
</ol>
<p>
    <br/>
</p>
<p>
    原理就是这样，好人甲在第一次启用TOTP的时候，网站会告诉他这个“固定不变的一段字符串”，这个串只有网站和甲才知道，所以网站和甲使用这个“串+当前时间”就可以生成当前时间对应的一次性密码。
</p>
<p>
    <br/>
</p>
<p>
    当然真的应用于实际场景，还是有许多完善的地方，比如：
</p>
<p>
    1.好人甲不可能知道hash算法是怎么算的，好多人连自己密码都记住，还要他记住“固定不变的一段字符串”，are you kidding me？！所以实际使用中，我们普通用户会用类似Google Authentication这样的app来帮助我们，这个app可以扫描网站提供的二维码来记住这个“固定不变的一段字符”并且在您需要的时候打开app就能看到“基于当前时间的一次性密码”
</p>
<p>
    2.如果一次性密码恰好基于当前时间也是不可行的，比如我在x年x月x日x时x分30秒打开app看到我Google的一次性密码是 123， 然后我输入到网页上提交花了5秒。Google在x年x月x日x时x分35秒计算得到789，然后和123一比较，卧槽！密码不对啊！！所以实际应用中会把你第一次启用TOTP的时间记录下来，然后30秒一个等份，这30秒区间内生成的一次性密码是一样的，并且网站在拿到用户输入的一次性密码之后会与当前等份，前一个等份，后一个等份共三个密码做比较，只要有一个匹配就是通过的了。（当然实际实现的时候每个网站不同，但大同小异）
</p>
<hr/>
<p>
    关于哈希算法，多说俩句：<br/>
</p>
<p>
    hejie：hash(A)得到B，如果A是比较短（长度10以下）的字符串，用普通的电脑就可以很快计算出A！
</p>
<p>
    路人甲：纳尼？你刚才不是说根据B没法算出A吗？
</p>
<p>
    hejie：是的，没有算法能够根据B逆向得到A，但是可以暴力破解！说白了就是一个个试！但是有俩个办法可以防止暴力破解：
</p>
<ol class=" list-paddingleft-2" style="list-style-type: decimal;">
    <li>
        <p>
            使用长度更长的A，这也是为什么很多网站叫你密码填长一点
        </p>
    </li>
    <li>
        <p>
            加盐（salt）哈希，就是：hash（A + salt）得到B，salt可以看成一个字符串，这样看这个公式是不是和TOTP算法很像？其实就是差不多的，TOTP算法就牛逼在他的想法，能想到这样设计的人才是最牛逼的！
        </p>
    </li>
</ol>
<p>
    hejie：还有啊，我刚才说“你找不到俩个不同的值但哈希结果一样”也是不完全对的，这种情况叫做哈希算法的“碰撞”。如果你能找到这样的“碰撞”，那你就牛逼了，这是可以上新闻的！
</p>
<p>
    我国著名科学家王小云在2004年就提出了能在普通机器上可观时间内寻找出MD5哈希算法“碰撞”的的方法，大家可以上网搜搜，挺厉害的！
</p>
<p>
    <br/>
</p>
<p>
    所以说啊，TOTP算法最难的还是哈希算法的实现，不过这个说起来没意思，大家也不一定看的下去。哈希算法的一种--MD5算法也就一俩百行代码，但如果你让我现场把它写出来我还真办不到。但是如果你感兴趣可以去了解一下它实现的原理。
</p>
<p>
    <br/>
</p>